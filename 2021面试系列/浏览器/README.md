### 1.浏览器的缓存

#### 强缓存

浏览器的缓存分类

- 需要发送HTTP请求，
- 不需要发送

检查强缓存，这个阶段不需要发送HTTP请求。

- HTTP/1.0时期，使用的是Expires
  - Expires：过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求  
    Expires: Wed, 22 Nov 2019 08:41:00 GMT  => 表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求
  - 缺点：服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的
- HTTP/1.1使用的是Cache-Control
  - Cache-Control：它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age  
    Cache-Control:max-age: 3600  => 代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存
  - private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
  - no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
  - no-store：非常粗暴，不进行任何形式的缓存。
  - s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间

> 当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑

#### 协商缓存

- 强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存
- 缓存tag分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样

Last-Modified:最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段

  - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
  - 否则返回304，告诉浏览器直接用缓存

ETag:是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器
  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
  - 否则返回304，告诉浏览器直接用缓存。

两者对比:

- 在精准度上，ETag优于Last-Modified。由于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
  - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
- 在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值

> 如果两种方式都支持的话，服务器会优先考虑ETag

#### 缓存位置

优先级由高到低
- Service Worker
  - Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。
  - 虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。
  - 其中的离线缓存就是 Service Worker Cache
  - Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性
- Memory Cache
- Disk Cache
- Push Cache

#### 总结

- 验证强缓存是否可用，通过Cache-Control(http1.0协议使用Expires)
- 清缓存失效下，使用协商缓存，2种方式，ETag/Last-Modified
  - 如果资源更新，返回资源和200
  - 否则返回304，让服务器直接从缓存获取资源


### 2.能不能说一说浏览器的本地存储？各自优劣如何

- cookie
  Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足，主要用来存储状态的
  - 容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息
  - 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容
  - 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。
  
- localStorage
  - localStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage
  - 容量。localStorage 的容量上限为5M，这个 5M 是针对一个域名的，因此对于一个域名是持久存储的
  - 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题
  - 接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法进行操作，非常方便
  
- sessionStorage
  - 和localStorage的区别，只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分sessionStorage就不复存在了
  - 应用场景：
    - 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
    - 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博就采取了这样的存储方式
  
- IndexedDB
  - 运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。

- 总结
  - cookie并不适合存储，而且存在非常多的缺陷。
  - Web Storage包括localStorage和sessionStorage, 默认不会参与和服务器的通信。
  - IndexedDB为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口


### 3.说一说从输入URL到页面呈现发生了什么——网络篇

- 1.构建请求，GET / HTTP/1.1
- 2.查找强缓存，如果有直接使用，否则进入下一步
- 3.DNS解析，找到域名对应的IP(数据包都是由IP携带)，DNS也有缓存功能，如果不制定端口，会默认才用IP的80端口
- 4.建立TCP连接(谷歌浏览器同时最多支持6个TCP连接),TCP的列成如下
  - 3次握手建立TCP连接
  - 发送数据包，数据包会分成一个一个的小包，接收方需要确认收到，否则会重新发送该小数据包，全部接受后，接收方按照顺序拼接成一个完整的数据包
  - 4次挥手断开TCP连接
- 5.发送HTTP请求，包括请求行，请求头，请求体
- 6.网络响应，返回数据给到浏览器，包括相应行，相应头，相应体
- 7.判断TCP中的Connection字段
  - Connectio: Keep-Alive，则TCP会一直保持连接，之后请求统一站点的资源会复用这个连接
  - 否则断开连接


### 4.说一说从输入URL到页面呈现发生了什么——解析算法篇

- 生成DOM树
  - 标记算法
  - 建树算法
- 生成DOM样式
  - 格式化样式：将CSS转化为渲染引擎能看懂的样式对象
  - 标准化样式：将一些渲染引擎不能看懂的样式转化为能看懂的，例如：rem=>px, white=>#000000, bold=>700
  - 计算样式：利用继承和层叠，继承指某个元素的样式会继承父辈的样式，父辈没有就会继承默认的样式，层叠指最终的样式取决于各个属性共同作用的效果
- 生成布局树