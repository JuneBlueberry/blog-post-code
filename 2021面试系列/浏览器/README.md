### 1.浏览器的缓存

#### 强缓存

浏览器的缓存分类

- 需要发送HTTP请求，
- 不需要发送

检查强缓存，这个阶段不需要发送HTTP请求。

- HTTP/1.0时期，使用的是Expires
  - Expires：过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求  
    Expires: Wed, 22 Nov 2019 08:41:00 GMT  => 表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求
  - 缺点：服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的
- HTTP/1.1使用的是Cache-Control
  - Cache-Control：它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age  
    Cache-Control:max-age: 3600  => 代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存
  - private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
  - no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
  - no-store：非常粗暴，不进行任何形式的缓存。
  - s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间

> 当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑

#### 协商缓存

- 强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存
- 缓存tag分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样

Last-Modified:最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段

  - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
  - 否则返回304，告诉浏览器直接用缓存

ETag:是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器
  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
  - 否则返回304，告诉浏览器直接用缓存。

两者对比:

- 在精准度上，ETag优于Last-Modified。由于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
  - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
- 在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值

> 如果两种方式都支持的话，服务器会优先考虑ETag

#### 缓存位置

优先级由高到低
- Service Worker
  - Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。
  - 虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。
  - 其中的离线缓存就是 Service Worker Cache
  - Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性
- Memory Cache
- Disk Cache
- Push Cache