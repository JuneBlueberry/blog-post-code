### 1.原型对象和构造函数的关系

- 在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。
- 当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。



### 2.描述一下原型链

对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。

- 对象的 hasOwnProperty() 来检查对象自身中是否含有该属性
- 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true


### 3.继承的实现

- 借助call
- 借助原型链
- 组合继承
- 组合继承的优化
- 寄生组合继承


### 4.面向对象的特征

- 封装
- 继承
- 多态


### 5.获取一个实例对象的属性

- 使用for...in...能获取到实例对象自身的属性和原型链上的属性
- 使用Object.keys()和Object.getOwnPropertyNames()只能获取实例对象自身的属性
- 可以通过hasOwnProperty()方法传入属性名来判断一个属性是不是实例自身的属性


### 6.class总结

基本概念
- 当你使用class的时候，它会默认调用constructor这个函数，来接收一些参数，并构造出一个新的实例对象(this)并将它返回。
- 如果你的class没有定义constructor，也会隐式生成一个constructor方法

定义属性的区别
- 在constructor中var一个变量，它只存在于constructor这个构造函数中
- 在constructor中使用this定义的属性和方法会被定义到实例上
- 在class中使用=来定义一个属性和方法，效果与第二点相同，会被定义到实例上
- 在class中直接定义一个方法，会被添加到原型对象prototype上

other
- class本质虽然是个函数，但是并不会像函数一样提升至作用域最顶层
- 使用class生成的实例对象，也会有沿着原型链查找的功能

注意
- constructor中定义的相同名称的属性和方法会覆盖在class里定义的。