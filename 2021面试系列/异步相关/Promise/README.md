### 1.什么是回调地狱

- 多层嵌套的问题
- 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性


### 2.Promise怎么解决回调地狱

- 实现链式调用，解决多层嵌套问题
- 实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题


### 3.为什么Promise要引入微任务？

如何处理回调
- 使用同步回调，直到异步任务进行完，再进行后面的任务  
  会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分等待的时间是可以拿来完成其他事情的，导致 CPU 的利用率非常低，而且还有另外一个致命的问题，就是无法实现延迟绑定的效果
- 使用异步回调，将回调函数放在进行宏任务队列的队尾
  执行回调(resolve/reject)的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿
- 使用异步回调，将回调函数放到当前宏任务中的最后面
  Promise 采取第三种方式, 即引入微任务, 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。

Promise利用微任务解决了什么
- 采用异步回调替代同步回调解决了浪费 CPU 性能的问题
- 放到当前宏任务最后执行，解决了回调执行的实时性问题



### Promise中的all和race

- Promise.all: 接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。或者有一个失败也会执行回调，并返回该失败

> 有一个场景是很适合用Promise.all，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。

- Promise.race: 接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。

> 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作

- Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。
- all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。